package main

import (
	"archive/tar"
	"compress/gzip"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

const (
	// ExploitDB GitLab repository (official source)
	exploitDBURL       = "https://gitlab.com/exploit-database/exploitdb/-/archive/main/exploitdb-main.tar.gz"
	exploitDBCSV       = "https://gitlab.com/exploit-database/exploitdb/-/raw/main/files_exploits.csv"
	exploitDBMirror    = "https://github.com/offensive-security/exploitdb/archive/refs/heads/main.tar.gz"
	exploitDBCSVMirror = "https://raw.githubusercontent.com/offensive-security/exploitdb/main/files_exploits.csv"
)

// UpdateExploitDB downloads and updates the bundled exploit database
func UpdateExploitDB() error {
	dbPath := GetExploitDBPath()

	fmt.Println(ColorCyan + "[*] " + ColorReset + "Updating exploit database...")
	fmt.Println(ColorCyan + "[*] " + ColorReset + "Target directory: " + dbPath)

	// Create directory if it doesn't exist
	if err := os.MkdirAll(dbPath, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Try to download from GitLab first (official source)
	fmt.Println(ColorCyan + "[*] " + ColorReset + "Downloading from GitLab (official)...")

	err := downloadExploitDB(exploitDBURL, dbPath)
	if err != nil {
		fmt.Println(ColorYellow + "[!] " + ColorReset + "GitLab failed, trying GitHub mirror...")
		err = downloadExploitDB(exploitDBMirror, dbPath)
		if err != nil {
			return fmt.Errorf("failed to download exploit database: %v", err)
		}
	}

	// Write version file
	versionPath := filepath.Join(dbPath, "VERSION")
	version := time.Now().Format("2006-01-02 15:04:05")
	if err := os.WriteFile(versionPath, []byte(version), 0644); err != nil {
		fmt.Println(ColorYellow + "[!] " + ColorReset + "Warning: Could not write version file")
	}

	// Clear cached database
	globalExploitDB = nil

	fmt.Println(ColorGreen + "[+] " + ColorReset + "Exploit database updated successfully!")
	fmt.Println(ColorGreen + "[+] " + ColorReset + "Version: " + version)

	// Print stats
	if db, err := LoadExploitDB(); err == nil {
		fmt.Println(ColorGreen + "[+] " + ColorReset + db.Stats())
	}

	return nil
}

// downloadExploitDB downloads and extracts the exploit database
func downloadExploitDB(url, destPath string) error {
	// Create HTTP client with timeout
	client := &http.Client{
		Timeout: 10 * time.Minute, // Large download
	}

	resp, err := client.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
	}

	// Get content length for progress
	totalSize := resp.ContentLength
	fmt.Printf(ColorCyan+"[*] "+ColorReset+"Download size: %.2f MB\n", float64(totalSize)/(1024*1024))

	// Create temp file
	tmpFile, err := os.CreateTemp("", "exploitdb-*.tar.gz")
	if err != nil {
		return err
	}
	defer os.Remove(tmpFile.Name())
	defer tmpFile.Close()

	// Download with progress
	fmt.Print(ColorCyan + "[*] " + ColorReset + "Downloading... ")

	written, err := io.Copy(tmpFile, resp.Body)
	if err != nil {
		fmt.Println(ColorRed + "FAILED" + ColorReset)
		return err
	}
	fmt.Printf(ColorGreen+"%.2f MB"+ColorReset+"\n", float64(written)/(1024*1024))

	// Extract
	fmt.Println(ColorCyan + "[*] " + ColorReset + "Extracting archive...")

	tmpFile.Seek(0, 0)
	if err := extractTarGz(tmpFile, destPath); err != nil {
		return err
	}

	return nil
}

// extractTarGz extracts a tar.gz archive
func extractTarGz(reader io.Reader, destPath string) error {
	gzr, err := gzip.NewReader(reader)
	if err != nil {
		return err
	}
	defer gzr.Close()

	tr := tar.NewReader(gzr)

	// Track what we extract
	filesExtracted := 0
	var rootDir string

	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		// Get the root directory name from first entry
		if rootDir == "" {
			parts := strings.SplitN(header.Name, "/", 2)
			if len(parts) > 0 {
				rootDir = parts[0]
			}
		}

		// Strip the root directory from the path
		name := header.Name
		if rootDir != "" && strings.HasPrefix(name, rootDir+"/") {
			name = strings.TrimPrefix(name, rootDir+"/")
		}
		if name == "" {
			continue
		}

		// Only extract specific files we need
		shouldExtract := false
		if name == "files_exploits.csv" || name == "files_shellcodes.csv" {
			shouldExtract = true
		} else if strings.HasPrefix(name, "exploits/") {
			// Only extract exploit files (not documentation, etc.)
			ext := strings.ToLower(filepath.Ext(name))
			if ext == ".py" || ext == ".rb" || ext == ".pl" || ext == ".sh" ||
			   ext == ".c" || ext == ".cpp" || ext == ".php" || ext == ".txt" ||
			   ext == ".html" || ext == ".java" || ext == ".js" {
				shouldExtract = true
			}
		}

		if !shouldExtract {
			continue
		}

		target := filepath.Join(destPath, name)

		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(target, 0755); err != nil {
				return err
			}
		case tar.TypeReg:
			// Create parent directory
			if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil {
				return err
			}

			// Create file
			outFile, err := os.Create(target)
			if err != nil {
				return err
			}

			if _, err := io.Copy(outFile, tr); err != nil {
				outFile.Close()
				return err
			}
			outFile.Close()

			filesExtracted++
			if filesExtracted%1000 == 0 {
				fmt.Printf(ColorCyan+"[*] "+ColorReset+"Extracted %d files...\n", filesExtracted)
			}
		}
	}

	fmt.Printf(ColorGreen+"[+] "+ColorReset+"Extracted %d files\n", filesExtracted)
	return nil
}

// QuickUpdateExploitDB does a quick update of just the CSV file
func QuickUpdateExploitDB() error {
	dbPath := GetExploitDBPath()

	fmt.Println(ColorCyan + "[*] " + ColorReset + "Quick update: downloading exploit index only...")

	if err := os.MkdirAll(dbPath, 0755); err != nil {
		return fmt.Errorf("failed to create directory: %v", err)
	}

	// Download just the CSV file (try GitLab first, then GitHub mirror)
	csvPath := filepath.Join(dbPath, "files_exploits.csv")

	// Try GitLab first
	csvURL := exploitDBCSV
	client := &http.Client{Timeout: 2 * time.Minute}
	resp, err := client.Get(csvURL)
	if err != nil || resp.StatusCode != http.StatusOK {
		if resp != nil {
			resp.Body.Close()
		}
		fmt.Println(ColorYellow + "[!] " + ColorReset + "GitLab failed, trying GitHub mirror...")
		csvURL = exploitDBCSVMirror
		resp, err = client.Get(csvURL)
		if err != nil {
			return err
		}
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("HTTP %d: %s", resp.StatusCode, resp.Status)
	}

	outFile, err := os.Create(csvPath)
	if err != nil {
		return err
	}
	defer outFile.Close()

	written, err := io.Copy(outFile, resp.Body)
	if err != nil {
		return err
	}

	fmt.Printf(ColorGreen+"[+] "+ColorReset+"Downloaded %.2f MB\n", float64(written)/(1024*1024))

	// Write version
	versionPath := filepath.Join(dbPath, "VERSION")
	version := time.Now().Format("2006-01-02 15:04:05") + " (index only)"
	os.WriteFile(versionPath, []byte(version), 0644)

	// Clear cache
	globalExploitDB = nil

	fmt.Println(ColorGreen + "[+] " + ColorReset + "Exploit index updated!")

	return nil
}

// PrintExploitDBHelp prints help information about the exploit database
func PrintExploitDBHelp() {
	fmt.Println(ColorCyan + ColorBold + "\nExploit Database Help" + ColorReset)
	fmt.Println(ColorCyan + "=====================" + ColorReset)
	fmt.Println()
	fmt.Println("The exploit database provides CVE and EDB-ID information for vulnerability")
	fmt.Println("detection during service scanning.")
	fmt.Println()
	fmt.Println(ColorPurple + "Commands:" + ColorReset)
	fmt.Println("  -searchsploit-update    Download/update the full exploit database (~500MB)")
	fmt.Println()
	fmt.Println(ColorPurple + "Usage:" + ColorReset)
	fmt.Println("  Use -vuln flag to enable vulnerability checking during scans")
	fmt.Println()
	fmt.Println(ColorPurple + "Example:" + ColorReset)
	fmt.Println("  # Update the database")
	fmt.Println("  ./gomap -searchsploit-update")
	fmt.Println()
	fmt.Println("  # Scan with vulnerability detection")
	fmt.Println("  ./gomap -t 192.168.1.1 -p 1-1000 -sV -vuln")
	fmt.Println()
	fmt.Println(ColorPurple + "Database Location:" + ColorReset)
	fmt.Println("  " + GetExploitDBPath())
	fmt.Println()

	// Print current status
	if IsExploitDBAvailable() {
		fmt.Println(ColorGreen + "[+] " + ColorReset + "Exploit database is available")
		fmt.Print(GetExploitDBInfo())
	} else {
		fmt.Println(ColorYellow + "[!] " + ColorReset + "Exploit database not found")
		fmt.Println("    Run with -searchsploit-update to download")
	}
}
