package main

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// ExploitEntry represents a single exploit from the database
type ExploitEntry struct {
	EDBID         string   `json:"edb_id"`
	CVE           string   `json:"cve,omitempty"`
	Title         string   `json:"title"`
	Platform      string   `json:"platform"`       // linux, windows, multiple, etc.
	Type          string   `json:"type"`           // webapps, remote, local, dos
	Verified      bool     `json:"verified"`
	FilePath      string   `json:"file_path"`      // relative path to exploit file
	DatePublished string   `json:"date_published"`
	Author        string   `json:"author,omitempty"`
	Port          int      `json:"port,omitempty"` // Associated port if known
}

// ExploitDatabase holds the loaded exploit database
type ExploitDatabase struct {
	Exploits       []ExploitEntry    `json:"exploits"`
	ByService      map[string][]int  `json:"-"` // Service name -> exploit indices
	ByPort         map[int][]int     `json:"-"` // Port -> exploit indices
	ByCVE          map[string][]int  `json:"-"` // CVE -> exploit indices
	LastUpdated    time.Time         `json:"last_updated"`
	Version        string            `json:"version"`
	ExploitDBPath  string            `json:"-"`
}

// Global exploit database instance
var globalExploitDB *ExploitDatabase

// GetExploitDBPath returns the path to the exploit database directory
func GetExploitDBPath() string {
	// First check if we're in the gomap directory
	execPath, err := os.Executable()
	if err == nil {
		dir := filepath.Dir(execPath)
		dbPath := filepath.Join(dir, "exploitdb")
		if _, err := os.Stat(dbPath); err == nil {
			return dbPath
		}
	}

	// Check current directory
	if _, err := os.Stat("exploitdb"); err == nil {
		return "exploitdb"
	}

	// Check home directory
	home, err := os.UserHomeDir()
	if err == nil {
		dbPath := filepath.Join(home, ".gomap", "exploitdb")
		if _, err := os.Stat(dbPath); err == nil {
			return dbPath
		}
	}

	// Default to current directory
	return "exploitdb"
}

// LoadExploitDB loads the exploit database from disk
func LoadExploitDB() (*ExploitDatabase, error) {
	if globalExploitDB != nil {
		return globalExploitDB, nil
	}

	dbPath := GetExploitDBPath()
	db := &ExploitDatabase{
		Exploits:      make([]ExploitEntry, 0),
		ByService:     make(map[string][]int),
		ByPort:        make(map[int][]int),
		ByCVE:         make(map[string][]int),
		ExploitDBPath: dbPath,
	}

	// Try to load from CSV file
	csvPath := filepath.Join(dbPath, "files_exploits.csv")
	if _, err := os.Stat(csvPath); err == nil {
		if err := db.loadFromCSV(csvPath); err != nil {
			return nil, fmt.Errorf("failed to load exploit database: %v", err)
		}
	} else {
		// Load from embedded data
		db.loadEmbeddedData()
	}

	// Load version info
	versionPath := filepath.Join(dbPath, "VERSION")
	if data, err := os.ReadFile(versionPath); err == nil {
		db.Version = strings.TrimSpace(string(data))
	}

	// Build indices
	db.buildIndices()

	globalExploitDB = db
	return db, nil
}

// loadFromCSV loads exploits from the ExploitDB CSV file
func (db *ExploitDatabase) loadFromCSV(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	reader.FieldsPerRecord = -1 // Variable number of fields

	// Read header
	header, err := reader.Read()
	if err != nil {
		return err
	}

	// Find column indices
	colIdx := make(map[string]int)
	for i, col := range header {
		colIdx[strings.ToLower(col)] = i
	}

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}

		entry := ExploitEntry{}

		if idx, ok := colIdx["id"]; ok && idx < len(record) {
			entry.EDBID = record[idx]
		}
		if idx, ok := colIdx["file"]; ok && idx < len(record) {
			entry.FilePath = record[idx]
		}
		if idx, ok := colIdx["description"]; ok && idx < len(record) {
			entry.Title = record[idx]
		}
		if idx, ok := colIdx["date"]; ok && idx < len(record) {
			entry.DatePublished = record[idx]
		}
		if idx, ok := colIdx["author"]; ok && idx < len(record) {
			entry.Author = record[idx]
		}
		if idx, ok := colIdx["type"]; ok && idx < len(record) {
			entry.Type = record[idx]
		}
		if idx, ok := colIdx["platform"]; ok && idx < len(record) {
			entry.Platform = record[idx]
		}
		if idx, ok := colIdx["verified"]; ok && idx < len(record) {
			entry.Verified = record[idx] == "1"
		}
		if idx, ok := colIdx["codes"]; ok && idx < len(record) {
			// Extract CVE from codes field
			codes := record[idx]
			if cveMatch := regexp.MustCompile(`CVE-\d{4}-\d+`).FindString(codes); cveMatch != "" {
				entry.CVE = cveMatch
			}
		}

		if entry.EDBID != "" {
			db.Exploits = append(db.Exploits, entry)
		}
	}

	return nil
}

// loadEmbeddedData loads the embedded vulnerability data
func (db *ExploitDatabase) loadEmbeddedData() {
	// Load from the ServiceVulnDB in vuln_data.go
	for service, entries := range ServiceVulnDB {
		for _, entry := range entries {
			for _, vuln := range entry.Vulns {
				exploit := ExploitEntry{
					EDBID:    vuln.EDBID,
					CVE:      vuln.CVE,
					Title:    vuln.Title,
					Platform: entry.Platform,
					Type:     entry.Type,
					Verified: vuln.Verified,
				}

				// Store service association
				exploit.FilePath = fmt.Sprintf("embedded/%s/%s", service, vuln.EDBID)

				db.Exploits = append(db.Exploits, exploit)
			}
		}
	}
}

// buildIndices builds lookup indices for fast searching
func (db *ExploitDatabase) buildIndices() {
	for i, exploit := range db.Exploits {
		// Index by CVE
		if exploit.CVE != "" {
			db.ByCVE[exploit.CVE] = append(db.ByCVE[exploit.CVE], i)
		}

		// Index by service keywords in title
		titleLower := strings.ToLower(exploit.Title)
		services := []string{
			"ssh", "ftp", "http", "https", "smb", "rdp", "mysql", "postgres",
			"redis", "mongodb", "apache", "nginx", "iis", "tomcat", "jenkins",
			"wordpress", "drupal", "joomla", "elasticsearch", "openssh", "vsftpd",
			"proftpd", "samba", "bind", "sendmail", "postfix", "exim", "telnet",
		}
		for _, svc := range services {
			if strings.Contains(titleLower, svc) {
				db.ByService[svc] = append(db.ByService[svc], i)
			}
		}

		// Index by port (extract from title or known associations)
		portPatterns := map[int][]string{
			21:    {"ftp"},
			22:    {"ssh", "openssh"},
			23:    {"telnet"},
			25:    {"smtp", "sendmail", "postfix", "exim"},
			53:    {"dns", "bind"},
			80:    {"http", "apache", "nginx", "iis"},
			110:   {"pop3"},
			139:   {"netbios", "smb"},
			143:   {"imap"},
			443:   {"https", "ssl"},
			445:   {"smb", "samba"},
			1433:  {"mssql", "sql server"},
			1521:  {"oracle"},
			3306:  {"mysql", "mariadb"},
			3389:  {"rdp", "remote desktop"},
			5432:  {"postgres"},
			5900:  {"vnc"},
			6379:  {"redis"},
			8080:  {"tomcat", "jenkins"},
			9200:  {"elasticsearch"},
			27017: {"mongodb"},
		}

		for port, patterns := range portPatterns {
			for _, pattern := range patterns {
				if strings.Contains(titleLower, pattern) {
					db.ByPort[port] = append(db.ByPort[port], i)
					break
				}
			}
		}
	}
}

// SearchByService finds exploits matching a service/version
func (db *ExploitDatabase) SearchByService(service, version string) []ExploitEntry {
	results := make([]ExploitEntry, 0)
	serviceLower := strings.ToLower(service)

	// Get potential matches from index
	indices, exists := db.ByService[serviceLower]
	if !exists {
		// Try partial match
		for svc, idx := range db.ByService {
			if strings.Contains(serviceLower, svc) || strings.Contains(svc, serviceLower) {
				indices = append(indices, idx...)
			}
		}
	}

	// Filter by version if provided
	versionLower := strings.ToLower(version)
	seen := make(map[string]bool)

	for _, idx := range indices {
		if idx >= len(db.Exploits) {
			continue
		}
		exploit := db.Exploits[idx]

		// Deduplicate
		if seen[exploit.EDBID] {
			continue
		}
		seen[exploit.EDBID] = true

		// If version is provided, check if it matches
		if version != "" {
			titleLower := strings.ToLower(exploit.Title)
			// Check if version appears in title
			if !strings.Contains(titleLower, versionLower) {
				// Try to match version patterns
				versionNum := extractVersionNumber(version)
				if versionNum != "" && !strings.Contains(titleLower, versionNum) {
					continue
				}
			}
		}

		results = append(results, exploit)
	}

	return results
}

// SearchByCVE finds exploits by CVE ID
func (db *ExploitDatabase) SearchByCVE(cve string) []ExploitEntry {
	results := make([]ExploitEntry, 0)

	cveUpper := strings.ToUpper(cve)
	if !strings.HasPrefix(cveUpper, "CVE-") {
		cveUpper = "CVE-" + cveUpper
	}

	if indices, exists := db.ByCVE[cveUpper]; exists {
		for _, idx := range indices {
			if idx < len(db.Exploits) {
				results = append(results, db.Exploits[idx])
			}
		}
	}

	return results
}

// SearchByPort finds exploits commonly associated with a port
func (db *ExploitDatabase) SearchByPort(port int) []ExploitEntry {
	results := make([]ExploitEntry, 0)
	seen := make(map[string]bool)

	if indices, exists := db.ByPort[port]; exists {
		for _, idx := range indices {
			if idx < len(db.Exploits) {
				exploit := db.Exploits[idx]
				if !seen[exploit.EDBID] {
					seen[exploit.EDBID] = true
					results = append(results, exploit)
				}
			}
		}
	}

	return results
}

// GetExploitPath returns the full path to an exploit file
func (db *ExploitDatabase) GetExploitPath(entry ExploitEntry) string {
	if strings.HasPrefix(entry.FilePath, "embedded/") {
		return entry.FilePath
	}
	return filepath.Join(db.ExploitDBPath, "exploits", entry.FilePath)
}

// extractVersionNumber extracts the main version number from a version string
func extractVersionNumber(version string) string {
	// Match patterns like "7.4", "2.3.4", etc.
	re := regexp.MustCompile(`(\d+\.\d+(?:\.\d+)?)`)
	matches := re.FindStringSubmatch(version)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

// CheckServiceVulnerabilities checks if a service version has known vulnerabilities
func CheckServiceVulnerabilities(service, version string, port int) []VulnerabilityInfo {
	vulns := make([]VulnerabilityInfo, 0)

	// First check the built-in vulnerability database
	vulns = append(vulns, checkBuiltInVulnDB(service, version)...)

	// Then check the exploit database if loaded
	db, err := LoadExploitDB()
	if err == nil {
		// Search by service
		exploits := db.SearchByService(service, version)
		for _, exp := range exploits {
			if len(vulns) >= 5 { // Limit results
				break
			}

			// Check if we already have this CVE
			duplicate := false
			for _, v := range vulns {
				if v.CVE != "" && v.CVE == exp.CVE {
					duplicate = true
					break
				}
			}
			if duplicate {
				continue
			}

			vuln := VulnerabilityInfo{
				CVE:         exp.CVE,
				EDBID:       exp.EDBID,
				Title:       exp.Title,
				Verified:    exp.Verified,
				ExploitPath: db.GetExploitPath(exp),
			}

			// Set default severity based on exploit type
			switch exp.Type {
			case "remote":
				vuln.Severity = "high"
			case "webapps":
				vuln.Severity = "medium"
			case "local":
				vuln.Severity = "low"
			case "dos":
				vuln.Severity = "medium"
			default:
				vuln.Severity = "medium"
			}

			vulns = append(vulns, vuln)
		}
	}

	return vulns
}

// ExploitDBStats returns statistics about the loaded database
func (db *ExploitDatabase) Stats() string {
	return fmt.Sprintf("Exploits: %d, Services indexed: %d, Ports indexed: %d, CVEs indexed: %d",
		len(db.Exploits), len(db.ByService), len(db.ByPort), len(db.ByCVE))
}

// IsExploitDBAvailable checks if the exploit database exists
func IsExploitDBAvailable() bool {
	dbPath := GetExploitDBPath()
	csvPath := filepath.Join(dbPath, "files_exploits.csv")
	if _, err := os.Stat(csvPath); err == nil {
		return true
	}
	// Check if we have embedded data
	return len(ServiceVulnDB) > 0
}

// GetExploitDBInfo returns information about the exploit database
func GetExploitDBInfo() string {
	dbPath := GetExploitDBPath()
	csvPath := filepath.Join(dbPath, "files_exploits.csv")

	info := "Exploit Database Info:\n"

	if stat, err := os.Stat(csvPath); err == nil {
		info += fmt.Sprintf("  Path: %s\n", dbPath)
		info += fmt.Sprintf("  Last Modified: %s\n", stat.ModTime().Format(time.RFC3339))

		// Count lines
		file, err := os.Open(csvPath)
		if err == nil {
			scanner := bufio.NewScanner(file)
			count := 0
			for scanner.Scan() {
				count++
			}
			file.Close()
			info += fmt.Sprintf("  Entries: ~%d\n", count-1)
		}
	} else {
		info += "  Using embedded vulnerability database\n"
		total := 0
		for _, entries := range ServiceVulnDB {
			for _, entry := range entries {
				total += len(entry.Vulns)
			}
		}
		info += fmt.Sprintf("  Embedded entries: %d\n", total)
	}

	versionPath := filepath.Join(dbPath, "VERSION")
	if data, err := os.ReadFile(versionPath); err == nil {
		info += fmt.Sprintf("  Version: %s\n", strings.TrimSpace(string(data)))
	}

	return info
}
