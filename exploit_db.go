package main

import (
	"bufio"
	"encoding/csv"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// ExploitEntry represents a single exploit from the database
type ExploitEntry struct {
	EDBID         string   `json:"edb_id"`
	CVE           string   `json:"cve,omitempty"`
	Title         string   `json:"title"`
	Platform      string   `json:"platform"`       // linux, windows, multiple, etc.
	Type          string   `json:"type"`           // webapps, remote, local, dos
	Verified      bool     `json:"verified"`
	FilePath      string   `json:"file_path"`      // relative path to exploit file
	DatePublished string   `json:"date_published"`
	Author        string   `json:"author,omitempty"`
	Port          int      `json:"port,omitempty"` // Associated port if known
}

// ExploitDatabase holds the loaded exploit database
type ExploitDatabase struct {
	Exploits       []ExploitEntry    `json:"exploits"`
	ByService      map[string][]int  `json:"-"` // Service name -> exploit indices
	ByPort         map[int][]int     `json:"-"` // Port -> exploit indices
	ByCVE          map[string][]int  `json:"-"` // CVE -> exploit indices
	LastUpdated    time.Time         `json:"last_updated"`
	Version        string            `json:"version"`
	ExploitDBPath  string            `json:"-"`
}

// Global exploit database instance
var globalExploitDB *ExploitDatabase

// GetExploitDBPath returns the path to the exploit database directory
func GetExploitDBPath() string {
	// First check if we're in the gomap directory
	execPath, err := os.Executable()
	if err == nil {
		dir := filepath.Dir(execPath)
		dbPath := filepath.Join(dir, "exploitdb")
		if _, err := os.Stat(dbPath); err == nil {
			return dbPath
		}
	}

	// Check current directory
	if _, err := os.Stat("exploitdb"); err == nil {
		return "exploitdb"
	}

	// Check home directory
	home, err := os.UserHomeDir()
	if err == nil {
		dbPath := filepath.Join(home, ".gomap", "exploitdb")
		if _, err := os.Stat(dbPath); err == nil {
			return dbPath
		}
	}

	// Default to current directory
	return "exploitdb"
}

// LoadExploitDB loads the exploit database from disk
func LoadExploitDB() (*ExploitDatabase, error) {
	if globalExploitDB != nil {
		return globalExploitDB, nil
	}

	dbPath := GetExploitDBPath()
	db := &ExploitDatabase{
		Exploits:      make([]ExploitEntry, 0),
		ByService:     make(map[string][]int),
		ByPort:        make(map[int][]int),
		ByCVE:         make(map[string][]int),
		ExploitDBPath: dbPath,
	}

	// Try to load from CSV file
	csvPath := filepath.Join(dbPath, "files_exploits.csv")
	if _, err := os.Stat(csvPath); err == nil {
		if err := db.loadFromCSV(csvPath); err != nil {
			return nil, fmt.Errorf("failed to load exploit database: %v", err)
		}
	} else {
		// Load from embedded data
		db.loadEmbeddedData()
	}

	// Load version info
	versionPath := filepath.Join(dbPath, "VERSION")
	if data, err := os.ReadFile(versionPath); err == nil {
		db.Version = strings.TrimSpace(string(data))
	}

	// Build indices
	db.buildIndices()

	globalExploitDB = db
	return db, nil
}

// loadFromCSV loads exploits from the ExploitDB CSV file
func (db *ExploitDatabase) loadFromCSV(path string) error {
	file, err := os.Open(path)
	if err != nil {
		return err
	}
	defer file.Close()

	reader := csv.NewReader(file)
	reader.FieldsPerRecord = -1 // Variable number of fields

	// Read header
	header, err := reader.Read()
	if err != nil {
		return err
	}

	// Find column indices
	colIdx := make(map[string]int)
	for i, col := range header {
		colIdx[strings.ToLower(col)] = i
	}

	for {
		record, err := reader.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			continue
		}

		entry := ExploitEntry{}

		if idx, ok := colIdx["id"]; ok && idx < len(record) {
			entry.EDBID = record[idx]
		}
		if idx, ok := colIdx["file"]; ok && idx < len(record) {
			entry.FilePath = record[idx]
		}
		if idx, ok := colIdx["description"]; ok && idx < len(record) {
			entry.Title = record[idx]
		}
		if idx, ok := colIdx["date"]; ok && idx < len(record) {
			entry.DatePublished = record[idx]
		}
		if idx, ok := colIdx["author"]; ok && idx < len(record) {
			entry.Author = record[idx]
		}
		if idx, ok := colIdx["type"]; ok && idx < len(record) {
			entry.Type = record[idx]
		}
		if idx, ok := colIdx["platform"]; ok && idx < len(record) {
			entry.Platform = record[idx]
		}
		if idx, ok := colIdx["verified"]; ok && idx < len(record) {
			entry.Verified = record[idx] == "1"
		}
		if idx, ok := colIdx["codes"]; ok && idx < len(record) {
			// Extract CVE from codes field
			codes := record[idx]
			if cveMatch := regexp.MustCompile(`CVE-\d{4}-\d+`).FindString(codes); cveMatch != "" {
				entry.CVE = cveMatch
			}
		}

		if entry.EDBID != "" {
			db.Exploits = append(db.Exploits, entry)
		}
	}

	return nil
}

// loadEmbeddedData loads the embedded vulnerability data
func (db *ExploitDatabase) loadEmbeddedData() {
	// Load from the ServiceVulnDB in vuln_data.go
	for service, entries := range ServiceVulnDB {
		for _, entry := range entries {
			for _, vuln := range entry.Vulns {
				exploit := ExploitEntry{
					EDBID:    vuln.EDBID,
					CVE:      vuln.CVE,
					Title:    vuln.Title,
					Platform: entry.Platform,
					Type:     entry.Type,
					Verified: vuln.Verified,
				}

				// Store service association
				exploit.FilePath = fmt.Sprintf("embedded/%s/%s", service, vuln.EDBID)

				db.Exploits = append(db.Exploits, exploit)
			}
		}
	}
}

// buildIndices builds lookup indices for fast searching
func (db *ExploitDatabase) buildIndices() {
	for i, exploit := range db.Exploits {
		// Index by CVE
		if exploit.CVE != "" {
			db.ByCVE[exploit.CVE] = append(db.ByCVE[exploit.CVE], i)
		}

		// Index by service keywords in title
		titleLower := strings.ToLower(exploit.Title)
		services := []string{
			"ssh", "ftp", "http", "https", "smb", "rdp", "mysql", "postgres",
			"redis", "mongodb", "apache", "nginx", "iis", "tomcat", "jenkins",
			"wordpress", "drupal", "joomla", "elasticsearch", "openssh", "vsftpd",
			"proftpd", "samba", "bind", "sendmail", "postfix", "exim", "telnet",
		}
		for _, svc := range services {
			if strings.Contains(titleLower, svc) {
				db.ByService[svc] = append(db.ByService[svc], i)
			}
		}

		// Index by port (extract from title or known associations)
		portPatterns := map[int][]string{
			21:    {"ftp"},
			22:    {"ssh", "openssh"},
			23:    {"telnet"},
			25:    {"smtp", "sendmail", "postfix", "exim"},
			53:    {"dns", "bind"},
			80:    {"http", "apache", "nginx", "iis"},
			110:   {"pop3"},
			139:   {"netbios", "smb"},
			143:   {"imap"},
			443:   {"https", "ssl"},
			445:   {"smb", "samba"},
			1433:  {"mssql", "sql server"},
			1521:  {"oracle"},
			3306:  {"mysql", "mariadb"},
			3389:  {"rdp", "remote desktop"},
			5432:  {"postgres"},
			5900:  {"vnc"},
			6379:  {"redis"},
			8080:  {"tomcat", "jenkins"},
			9200:  {"elasticsearch"},
			27017: {"mongodb"},
		}

		for port, patterns := range portPatterns {
			for _, pattern := range patterns {
				if strings.Contains(titleLower, pattern) {
					db.ByPort[port] = append(db.ByPort[port], i)
					break
				}
			}
		}
	}
}

// SearchByService finds exploits matching a service/version
func (db *ExploitDatabase) SearchByService(service, version string) []ExploitEntry {
	results := make([]ExploitEntry, 0)
	serviceLower := strings.ToLower(service)

	// Get potential matches from index
	indices, exists := db.ByService[serviceLower]
	if !exists {
		// Try partial match
		for svc, idx := range db.ByService {
			if strings.Contains(serviceLower, svc) || strings.Contains(svc, serviceLower) {
				indices = append(indices, idx...)
			}
		}
	}

	// Filter by version if provided
	versionLower := strings.ToLower(version)
	seen := make(map[string]bool)

	for _, idx := range indices {
		if idx >= len(db.Exploits) {
			continue
		}
		exploit := db.Exploits[idx]

		// Deduplicate
		if seen[exploit.EDBID] {
			continue
		}
		seen[exploit.EDBID] = true

		// If version is provided, check if it matches
		if version != "" {
			titleLower := strings.ToLower(exploit.Title)
			// Check if version appears in title
			if !strings.Contains(titleLower, versionLower) {
				// Try to match version patterns using service-aware extraction
				versionNum := extractVersionForService(version, service)
				if versionNum != "" && !strings.Contains(titleLower, versionNum) {
					continue
				}
			}
		}

		results = append(results, exploit)
	}

	return results
}

// SearchByCVE finds exploits by CVE ID
func (db *ExploitDatabase) SearchByCVE(cve string) []ExploitEntry {
	results := make([]ExploitEntry, 0)

	cveUpper := strings.ToUpper(cve)
	if !strings.HasPrefix(cveUpper, "CVE-") {
		cveUpper = "CVE-" + cveUpper
	}

	if indices, exists := db.ByCVE[cveUpper]; exists {
		for _, idx := range indices {
			if idx < len(db.Exploits) {
				results = append(results, db.Exploits[idx])
			}
		}
	}

	return results
}

// SearchByPort finds exploits commonly associated with a port
func (db *ExploitDatabase) SearchByPort(port int) []ExploitEntry {
	results := make([]ExploitEntry, 0)
	seen := make(map[string]bool)

	if indices, exists := db.ByPort[port]; exists {
		for _, idx := range indices {
			if idx < len(db.Exploits) {
				exploit := db.Exploits[idx]
				if !seen[exploit.EDBID] {
					seen[exploit.EDBID] = true
					results = append(results, exploit)
				}
			}
		}
	}

	return results
}

// GetExploitPath returns the full path to an exploit file
func (db *ExploitDatabase) GetExploitPath(entry ExploitEntry) string {
	if strings.HasPrefix(entry.FilePath, "embedded/") {
		return entry.FilePath
	}
	return filepath.Join(db.ExploitDBPath, "exploits", entry.FilePath)
}

// extractVersionNumber extracts the main version number from a version string
// It uses service-aware patterns to avoid extracting protocol versions (e.g., "2.0" from "SSH-2.0")
func extractVersionNumber(version string) string {
	return extractVersionForService(version, "")
}

// extractVersionForService extracts version number with service context awareness
// This prevents extracting protocol versions like "2.0" from "SSH-2.0-OpenSSH_10.2p1"
func extractVersionForService(version, service string) string {
	versionLower := strings.ToLower(version)
	serviceLower := strings.ToLower(service)

	// Service-specific version extraction patterns
	// These patterns are ordered by specificity - most specific first

	// SSH: Extract version after OpenSSH_, OpenSSH/, or similar
	// Banner format: "SSH-2.0-OpenSSH_10.2p1 Debian-3"
	if strings.Contains(versionLower, "openssh") || serviceLower == "ssh" || serviceLower == "openssh" {
		// Match OpenSSH_X.X or OpenSSH/X.X or OpenSSH X.X
		sshRe := regexp.MustCompile(`(?i)openssh[_/\s-]?(\d+\.\d+(?:\.\d+)?(?:p\d+)?)`)
		if matches := sshRe.FindStringSubmatch(version); len(matches) > 1 {
			// Strip the 'p' suffix for version comparison (e.g., "10.2p1" -> "10.2")
			verNum := regexp.MustCompile(`(\d+\.\d+(?:\.\d+)?)`).FindString(matches[1])
			if verNum != "" {
				return verNum
			}
			return matches[1]
		}
	}

	// Apache: Extract version after "Apache/"
	// Banner format: "Apache/2.4.49 (Unix)"
	if strings.Contains(versionLower, "apache") || serviceLower == "apache" {
		apacheRe := regexp.MustCompile(`(?i)apache[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := apacheRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// nginx: Extract version after "nginx/"
	// Banner format: "nginx/1.18.0"
	if strings.Contains(versionLower, "nginx") || serviceLower == "nginx" {
		nginxRe := regexp.MustCompile(`(?i)nginx[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := nginxRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// vsftpd: Extract version after "vsFTPd" or "vsftpd"
	// Banner format: "220 (vsFTPd 2.3.4)"
	if strings.Contains(versionLower, "vsftpd") || serviceLower == "vsftpd" {
		vsftpdRe := regexp.MustCompile(`(?i)vsftpd[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := vsftpdRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// ProFTPD: Extract version after "ProFTPD"
	// Banner format: "220 ProFTPD 1.3.5 Server"
	if strings.Contains(versionLower, "proftpd") || serviceLower == "proftpd" {
		proftpdRe := regexp.MustCompile(`(?i)proftpd[/\s-]?(\d+\.\d+(?:\.\d+)?[a-z]?)`)
		if matches := proftpdRe.FindStringSubmatch(version); len(matches) > 1 {
			// Strip trailing letters for comparison (e.g., "1.3.3c" -> "1.3.3")
			verNum := regexp.MustCompile(`(\d+\.\d+(?:\.\d+)?)`).FindString(matches[1])
			if verNum != "" {
				return verNum
			}
			return matches[1]
		}
	}

	// Tomcat: Extract version after "Tomcat" or "Apache-Coyote"
	if strings.Contains(versionLower, "tomcat") || serviceLower == "tomcat" {
		tomcatRe := regexp.MustCompile(`(?i)(?:tomcat|coyote)[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := tomcatRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// IIS: Extract version after "IIS" or "Microsoft-IIS"
	if strings.Contains(versionLower, "iis") || serviceLower == "iis" {
		iisRe := regexp.MustCompile(`(?i)iis[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := iisRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Werkzeug (Python): Extract version after "Werkzeug/"
	// Banner format: "Werkzeug/3.1.5 Python/3.13.11"
	if strings.Contains(versionLower, "werkzeug") {
		werkzeugRe := regexp.MustCompile(`(?i)werkzeug[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := werkzeugRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// MySQL/MariaDB: Extract version number
	if strings.Contains(versionLower, "mysql") || strings.Contains(versionLower, "mariadb") ||
		serviceLower == "mysql" || serviceLower == "mariadb" {
		mysqlRe := regexp.MustCompile(`(?i)(?:mysql|mariadb)[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := mysqlRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// PostgreSQL: Extract version number
	if strings.Contains(versionLower, "postgres") || serviceLower == "postgres" || serviceLower == "postgresql" {
		pgRe := regexp.MustCompile(`(?i)postgres(?:ql)?[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := pgRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Redis: Extract version number
	if strings.Contains(versionLower, "redis") || serviceLower == "redis" {
		redisRe := regexp.MustCompile(`(?i)redis[/\s_-]?(?:server[/\s_-]?)?v?(\d+\.\d+(?:\.\d+)?)`)
		if matches := redisRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Jenkins: Extract version number
	if strings.Contains(versionLower, "jenkins") || serviceLower == "jenkins" {
		jenkinsRe := regexp.MustCompile(`(?i)jenkins[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := jenkinsRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Elasticsearch: Extract version number
	if strings.Contains(versionLower, "elasticsearch") || serviceLower == "elasticsearch" {
		esRe := regexp.MustCompile(`(?i)elasticsearch[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := esRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Samba: Extract version number
	if strings.Contains(versionLower, "samba") || serviceLower == "samba" {
		sambaRe := regexp.MustCompile(`(?i)samba[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := sambaRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// WordPress: Extract version number
	if strings.Contains(versionLower, "wordpress") || serviceLower == "wordpress" {
		wpRe := regexp.MustCompile(`(?i)wordpress[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := wpRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Drupal: Extract version number
	if strings.Contains(versionLower, "drupal") || serviceLower == "drupal" {
		drupalRe := regexp.MustCompile(`(?i)drupal[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := drupalRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Joomla: Extract version number
	if strings.Contains(versionLower, "joomla") || serviceLower == "joomla" {
		joomlaRe := regexp.MustCompile(`(?i)joomla[/\s!-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := joomlaRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Apache Struts: Extract version number
	if strings.Contains(versionLower, "struts") || serviceLower == "struts" {
		strutsRe := regexp.MustCompile(`(?i)struts[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := strutsRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Oracle WebLogic: Extract version number
	// Banner format: "WebLogic Server 12.2.1.3" or similar
	if strings.Contains(versionLower, "weblogic") || serviceLower == "weblogic" {
		weblogicRe := regexp.MustCompile(`(?i)weblogic[/\s-]?(?:server[/\s-]?)?(\d+\.\d+(?:\.\d+)?(?:\.\d+)?)`)
		if matches := weblogicRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// VNC Server: Extract version number
	// Banner format: "RFB 003.008" (protocol) or "RealVNC 4.1.1"
	if strings.Contains(versionLower, "vnc") || serviceLower == "vnc" || serviceLower == "vncserver" {
		// Try to match software version first (e.g., RealVNC 4.1.1)
		vncSoftRe := regexp.MustCompile(`(?i)(?:realvnc|tightvnc|ultravnc|tigervnc)[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := vncSoftRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
		// Fall back to RFB protocol version
		vncRfbRe := regexp.MustCompile(`(?i)rfb[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := vncRfbRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// OpenSSL (for Heartbleed detection): Extract version number
	// Banner format: "OpenSSL/1.0.1f" or "OpenSSL 1.0.1"
	if strings.Contains(versionLower, "openssl") || serviceLower == "openssl" || serviceLower == "heartbleed" {
		opensslRe := regexp.MustCompile(`(?i)openssl[/\s-]?(\d+\.\d+\.\d+[a-z]?)`)
		if matches := opensslRe.FindStringSubmatch(version); len(matches) > 1 {
			// Strip trailing letter for comparison (e.g., "1.0.1f" -> "1.0.1")
			verNum := regexp.MustCompile(`(\d+\.\d+\.\d+)`).FindString(matches[1])
			if verNum != "" {
				return verNum
			}
			return matches[1]
		}
	}

	// Bash (for Shellshock detection): Extract version number
	// Banner format: "GNU bash, version 4.3.11(1)-release"
	if strings.Contains(versionLower, "bash") || serviceLower == "bash" || serviceLower == "shellshock" {
		bashRe := regexp.MustCompile(`(?i)bash[,/\s-]?(?:version[/\s-]?)?(\d+\.\d+(?:\.\d+)?)`)
		if matches := bashRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// Log4j: Extract version number
	// May appear in headers or error messages
	if strings.Contains(versionLower, "log4j") || serviceLower == "log4j" {
		log4jRe := regexp.MustCompile(`(?i)log4j[/\s-]?(\d+\.\d+(?:\.\d+)?)`)
		if matches := log4jRe.FindStringSubmatch(version); len(matches) > 1 {
			return matches[1]
		}
	}

	// SMB: Windows SMB typically doesn't expose version in banner easily
	// but we handle it via the fallback for any version-like patterns
	// SMBv1, SMBv2, SMBv3 protocol versions are handled separately

	// Generic fallback: Find the LAST version-like pattern in the string
	// This avoids protocol versions which typically appear first
	re := regexp.MustCompile(`(\d+\.\d+(?:\.\d+)?)`)
	allMatches := re.FindAllString(version, -1)
	if len(allMatches) > 0 {
		// Return the last match, which is more likely to be the software version
		// rather than a protocol version
		return allMatches[len(allMatches)-1]
	}

	return ""
}

// CheckServiceVulnerabilities checks if a service version has known vulnerabilities
func CheckServiceVulnerabilities(service, version string, port int) []VulnerabilityInfo {
	vulns := make([]VulnerabilityInfo, 0)

	// First check the built-in vulnerability database
	vulns = append(vulns, checkBuiltInVulnDB(service, version)...)

	// Then check the exploit database if loaded
	db, err := LoadExploitDB()
	if err == nil {
		// Search by service
		exploits := db.SearchByService(service, version)
		for _, exp := range exploits {
			if len(vulns) >= 5 { // Limit results
				break
			}

			// Check if we already have this CVE
			duplicate := false
			for _, v := range vulns {
				if v.CVE != "" && v.CVE == exp.CVE {
					duplicate = true
					break
				}
			}
			if duplicate {
				continue
			}

			vuln := VulnerabilityInfo{
				CVE:         exp.CVE,
				EDBID:       exp.EDBID,
				Title:       exp.Title,
				Verified:    exp.Verified,
				ExploitPath: db.GetExploitPath(exp),
			}

			// Set default severity based on exploit type
			switch exp.Type {
			case "remote":
				vuln.Severity = "high"
			case "webapps":
				vuln.Severity = "medium"
			case "local":
				vuln.Severity = "low"
			case "dos":
				vuln.Severity = "medium"
			default:
				vuln.Severity = "medium"
			}

			vulns = append(vulns, vuln)
		}
	}

	return vulns
}

// ExploitDBStats returns statistics about the loaded database
func (db *ExploitDatabase) Stats() string {
	return fmt.Sprintf("Exploits: %d, Services indexed: %d, Ports indexed: %d, CVEs indexed: %d",
		len(db.Exploits), len(db.ByService), len(db.ByPort), len(db.ByCVE))
}

// IsExploitDBAvailable checks if the exploit database exists
func IsExploitDBAvailable() bool {
	dbPath := GetExploitDBPath()
	csvPath := filepath.Join(dbPath, "files_exploits.csv")
	if _, err := os.Stat(csvPath); err == nil {
		return true
	}
	// Check if we have embedded data
	return len(ServiceVulnDB) > 0
}

// GetExploitDBInfo returns information about the exploit database
func GetExploitDBInfo() string {
	dbPath := GetExploitDBPath()
	csvPath := filepath.Join(dbPath, "files_exploits.csv")

	info := "Exploit Database Info:\n"

	if stat, err := os.Stat(csvPath); err == nil {
		info += fmt.Sprintf("  Path: %s\n", dbPath)
		info += fmt.Sprintf("  Last Modified: %s\n", stat.ModTime().Format(time.RFC3339))

		// Count lines
		file, err := os.Open(csvPath)
		if err == nil {
			scanner := bufio.NewScanner(file)
			count := 0
			for scanner.Scan() {
				count++
			}
			file.Close()
			info += fmt.Sprintf("  Entries: ~%d\n", count-1)
		}
	} else {
		info += "  Using embedded vulnerability database\n"
		total := 0
		for _, entries := range ServiceVulnDB {
			for _, entry := range entries {
				total += len(entry.Vulns)
			}
		}
		info += fmt.Sprintf("  Embedded entries: %d\n", total)
	}

	versionPath := filepath.Join(dbPath, "VERSION")
	if data, err := os.ReadFile(versionPath); err == nil {
		info += fmt.Sprintf("  Version: %s\n", strings.TrimSpace(string(data)))
	}

	return info
}
